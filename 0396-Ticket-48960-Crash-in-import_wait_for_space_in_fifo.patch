From 781019533245833d33c591a28cebeeefa391abb6 Mon Sep 17 00:00:00 2001
From: Thierry Bordaz <tbordaz@redhat.com>
Date: Fri, 19 Aug 2016 14:32:47 +0200
Subject: [PATCH] Ticket 48960 Crash in import_wait_for_space_in_fifo().

Bug Description:
    At online total import on a consumer, the total import startup
    function allocates a fifo queue and monitor the overall import.
    This queue contain the entries later received during import.

    When monitoring ends (import complete or error) it frees
    the queue.

    Under error condition, there is a possibility that monitoring
    ends while entries are still received (bulk_import_queue).
    So there is a risk that the received entries will be added into
    the queue at the same time the monitoring thread frees the queue

Fix Description:
    The thread storing the entries into the queue runs while
    holding the job->wire_lock.

    To prevent the monitoring thread to frees the queue under
    bulk_import_queue, make sure to acquire job->wire_lock
    before calling import_free_job

https://fedorahosted.org/389/ticket/48960

Reviewed by: Mark Reynolds (thanks Mark !)

Platforms tested: F23

Flag Day: no

Doc impact: no

(cherry picked from commit 855c34e46373cdb9747a391acf1099e2e3df696f)
(cherry picked from commit ef0b98b32862580299d3415853dc62a20f0496bd)
---
 ldap/servers/slapd/back-ldbm/import-threads.c |  5 +++++
 ldap/servers/slapd/back-ldbm/import.c         | 15 ++++++++++++++-
 2 files changed, 19 insertions(+), 1 deletion(-)

diff --git a/ldap/servers/slapd/back-ldbm/import-threads.c b/ldap/servers/slapd/back-ldbm/import-threads.c
index 954abf2..df19424 100644
--- a/ldap/servers/slapd/back-ldbm/import-threads.c
+++ b/ldap/servers/slapd/back-ldbm/import-threads.c
@@ -2845,6 +2845,11 @@ static int bulk_import_queue(ImportJob *job, Slapi_Entry *entry)
         return -1;
     }
 
+    /* The import is aborted, just ignore that entry */
+    if(job->flags & FLAG_ABORT) {
+        return -1;
+    }
+
     PR_Lock(job->wire_lock);
     /* Let's do this inside the lock !*/
     id = job->lead_ID + 1;
diff --git a/ldap/servers/slapd/back-ldbm/import.c b/ldap/servers/slapd/back-ldbm/import.c
index e3966ff..81c3c15 100644
--- a/ldap/servers/slapd/back-ldbm/import.c
+++ b/ldap/servers/slapd/back-ldbm/import.c
@@ -386,8 +386,21 @@ void import_free_job(ImportJob *job)
     
     ldbm_back_free_incl_excl(job->include_subtrees, job->exclude_subtrees);
     charray_free(job->input_filenames);
-    if (job->fifo.size)
+    if (job->fifo.size) {
+        /* bulk_import_queue is running, while holding the job lock.
+         * bulk_import_queue is using the fifo queue.
+         * To avoid freeing fifo queue under bulk_import_queue use
+         * job lock to synchronize
+         */
+        if (job->wire_lock)
+            PR_Lock(job->wire_lock);
+
         import_fifo_destroy(job);
+
+        if (job->wire_lock)
+            PR_Unlock(job->wire_lock);
+    }
+
     if (NULL != job->uuid_namespace)
         slapi_ch_free((void **)&job->uuid_namespace);
     if (job->wire_lock)
-- 
2.4.11

